#include "main.h"
#include <math.h>

static volatile unsigned int TimingDelay;
RCC_ClocksTypeDef RCC_Clocks;

/* Private Function prototypes -----------------------------------------------*/
void  RCC_Configuration(void);
void  RTC_Configuration(void);
void  Init_GPIOs (void);
void  Init_Board(void);
/*******************************************************************************/

/*
  
  Music Game

  As music plays, indicators scroll across the screen. Press the button
  when the indicator reaches the symbol on the left, in time with the music.

  For the best experience, connect a small speaker between PB7 and GND.
  However, the game is completely playable without a speaker (just look at the screen).

  The game is lost by pressing the button when there is no indicator or
  not pressing the button when there is an indicator.

  Win the game by making it to the end of the song.

  The game has two songs/levels - the "Nokia Tune" ringtone that was on everyone's
  phone in the 90's, and a shortened version of "Such Great Heights" by The Postal Service
  (selected because of its simple percussion and unsyncopated melody).

  Currently, there is no way to select a particular song/level, so the game alternates between the two.

  Songs/levels are stored as packed "tracks" of messages, described in detail below.
  The method of storing tracks was designed to be memory-efficient and extensible,
  allowing for a variety of songs to be played. However, translating a song into
  a packed track is a time-consuming process, so I only included two.

  Sound is generated by rapidly turning the GPIO pin on and off. Using this, square waves of varying
  duty cycle/pulse width can be created for different notes. The kick drum is a rapid
  sequence of out-of-tune bass notes, and the snare drum is created using (pseudo)random noise.

  The game has a primitive menu system: whenever text appears on the screen
  (e.g., "U WIN"/"U LOSE"/song title), the user must press the button to continue.

*/


/*

  TRACK PACKING SCHEME:

  The first value of a packed track is the BPM of the track.

  Each message on a track is packed into a 16-bit integer for efficient storage.
  A message can contain a note, percussion, and a flag which determines if
  the beat should show up on the screen.

  15 (MSB) - Show Beat (0=not shown, 1=shown)
  14 thru 8 - Note Pitch (0=off, 1 thru 127 according to MIDI standard)
  7 thru 6 - Duty Cycle (0=50%, 1=25%, 2=12.5%, 3=6.25%)
  5 thru 4 - Percussion (0=off, 1=kick drum, 2=snare drum, 3=undefined)
  3 thru 0 - Note Duration (0=1 beat, 1=2 beats, ..., 15=16 beats)

  Tracks should be terminated with a 0 value (similar to strings).

  Tracks were packed using this spreadsheet:
  https://docs.google.com/spreadsheets/d/1-OWIzfYmzyANGwhCr_5O-vbClmRVI619PKY74gCAoMc/edit?usp=sharing

*/

const uint16_t MASK_INDICATOR  = 0x8000;
const uint16_t MASK_NOTE       = 0x7F00;
const uint16_t MASK_DUTY_CYCLE = 0x00C0;
const uint16_t MASK_DURATION   = 0x000F;


const uint16_t PERC_NONE =  0b00 << 4;
const uint16_t PERC_KICK =  0b01 << 4;
const uint16_t PERC_SNARE = 0b10 << 4;

// "Nokia Tune" - Francisco Tárrega
uint16_t nokiaTune[] = {
240, // BPM
0x00C7, 0x4CD0, 0x4AC0, 0xC2D1, 0x44C1, 0xC9D0, 0x47C0, 0xBED1,
0x40C1, 0xC7D0, 0x45C0, 0xBDD1, 0x40C1, 0xC5E3, 0x00C1, 0xCCD0,
0x4AC0, 0xC2D1, 0x44C1, 0xC9D0, 0x47C0, 0xBED1, 0x40C1, 0xC7D0,
0x45C0, 0xBDD1, 0x40C1, 0xC5E3, 0x00C1,  
0 // Terminator
};

// "Such Great Heights" - The Postal Service
uint16_t suchGreatHeights[] = {
160, // BPM
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x4380,
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x3E80, 0x4380,
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3C80, 0x3C80, 0x3C80, 0x3C80, 0x4080, 0x4080, 0x4080, 0x4080,
0x3E90, 0xBEA0, 0x3E90, 0xBEA0, 0x3E90, 0xBEA0, 0x3E90, 0xC3A0,
0x3C90, 0xBCA0, 0x3C90, 0xBCA0, 0x4090, 0xC0A0, 0x4090, 0xC0A0,
0x3C90, 0xBCA0, 0x3C90, 0xBCA0, 0x4090, 0xC0A0, 0x4090, 0xC0A0,
0x3E90, 0xBEA0, 0x3E90, 0xBEA0, 0x3E90, 0xBEA0, 0x3E90, 0xC3A0,
0x3C90, 0xBCA0, 0x3C90, 0xBCA0, 0x4090, 0xC0A0, 0x4090, 0xC0A0,
0x3C90, 0xBCA0, 0x3C90, 0xBCA0, 0x4090, 0xC0A0, 0x4090, 0xC0A0,
0x3E90, 0x3EA0, 0x3E90, 0x3EA0, 0x3E90, 0x3EA0, 0x3E90, 0x3EA0,
0xC190, 0x41A0, 0x0090, 0x3CA0, 0xC190, 0x41A0, 0xC190, 0x43A0,
0xC090, 0x40A0, 0x0090, 0x3CA0, 0xC090, 0x40A0, 0xC090, 0x41A0,
0xBE90, 0x3CA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0,
0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x39A0, 0xB790, 0x35A0,
0xC190, 0x41A0, 0x0090, 0x3CA0, 0xC190, 0x41A0, 0xC190, 0x43A0,
0xC090, 0x40A0, 0x0090, 0x3CA0, 0xC090, 0x40A0, 0xC090, 0x41A0,
0xBE90, 0x3CA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0,
0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x39A0, 0xB790, 0x35A0,
0xC190, 0x41A0, 0x0090, 0x3CA0, 0xC190, 0x41A0, 0xC190, 0x43A0,
0xC090, 0x40A0, 0x0090, 0x3CA0, 0xC090, 0x40A0, 0xC090, 0x41A0,
0xBE90, 0x3CA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0,
0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x39A0, 0xB790, 0x35A0,
0xC190, 0x41A0, 0x0090, 0x3CA0, 0xC190, 0x41A0, 0xC190, 0x43A0,
0xC090, 0x40A0, 0x0090, 0x3CA0, 0xC090, 0x40A0, 0xC090, 0x41A0,
0xBE90, 0x3CA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0,
0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x39A0, 0xB790, 0x35A0,
0xBC90, 0x3CA0, 0xBC90, 0x3CA0, 0xBC90, 0x39A0, 0x3C90, 0xBEA0,
0x3E90, 0xBCA0, 0x3C90, 0xBCA0, 0x3C90, 0xBEA0, 0x3E90, 0xC1A0,
0x4190, 0xBAA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x3AA0,
0xB990, 0x39A0, 0x3990, 0x39A0, 0x3990, 0x39A0, 0x3990, 0x35A0,
0xBC90, 0x3CA0, 0xBC90, 0x3CA0, 0xBC90, 0x39A0, 0x3C90, 0xBEA0,
0x3E90, 0xBCA0, 0x3C90, 0xBCA0, 0x3C90, 0xBEA0, 0x3E90, 0xC1A0,
0x4190, 0xBAA0, 0x3A90, 0x3AA0, 0x3A90, 0x3AA0, 0xBA90, 0x3AA0,
0xBE90, 0x3EA0, 0xB990, 0x39A0, 0x3990, 0x39A0, 0x3590, 0x35A0,
0xB590,
0 // Terminator
};

// ===== TIMING RELATED CODE =====

// Busy-wait function for accurate sub-millisecond timing.
void busyWait(int cycles) {
  for (int i = 0; i < cycles; ++i);
}

// Measures the number of busy-wait cycles per second.
int busyWaitCyclesPerSecond = 0;

void calibrateBusyWait() {
  TimingDelay = 4096;
  busyWait(1000000);
  int millisPerMillionCycles = 4096 - TimingDelay;
  busyWaitCyclesPerSecond = 1000000000.0F/millisPerMillionCycles;
}

// Set the number of milliseconds per beat based on the number of beats per minute.
int millisPerBeat = 0;

void setBPM(float tempo) {
  tempo = 1.0F / tempo;
  tempo *= 60; // 60 sec per min
  tempo *= 1000; // 1000 msec per sec
  millisPerBeat = tempo;
}



// ===== AUDIO RELATED CODE =====

// Play a square waveform, on for timeOn cycles and off for timeOff cycles.
void playWave(int timeOn, int timeOff) {
  GPIO_SetBits(GPIOB, GPIO_Pin_7);
  busyWait(timeOn);
  GPIO_ResetBits(GPIOB, GPIO_Pin_7);
  busyWait(timeOff);
}

// Convert a MIDI pitch (0-127) to the number of busy-wait cycles required to produce the pitch.
int midiNoteToCycles(int noteInt) {
  float note = (float)noteInt;
  note = 69 - note; // Negative offset from A4
  note /= 12; // 12 half-steps per octave
  note = pow(2, note); // Notes follow a logarithmic scale
  note *= busyWaitCyclesPerSecond; // busyWait() function takes # of loop cycles
  note /= 440; // A4 = 440 Hz
  return (int)note;
}

// Play a note of the specified MIDI pitch and duty cycle
// until the TimingDelay reaches 0.
void playNote(int midiNote, int dutyCycle) {
  if (midiNote) {
    int cycles = midiNoteToCycles(midiNote);
    int cyclesOn = cycles >> dutyCycle;
    int cyclesOff = cycles - cyclesOn;
    while (TimingDelay != 0) {
      playWave(cyclesOn, cyclesOff);
    }
  } else {
    while (TimingDelay != 0);
  }
}

// Play a kick-drum sound, taking about 80ms.
// Plays a series of out-of-tune bass notes in rapid succession to mimic a low drum sound.
void playKick() {
  int minCycles = busyWaitCyclesPerSecond / 400;
  int maxCycles = minCycles * 4;
  int stepCycles = (maxCycles - minCycles)/8;

  for (int cycles = minCycles; cycles < maxCycles; cycles += stepCycles) {
    playWave(cycles, cycles);
  }
}

// Used to calculate random noise for snare drum
uint32_t randomSeed = 0x13d701e8;

// Play a snare-drum sound, taking 80ms.
// Produces a crude random noise by sending the output of a pseudorandom nubmer generator directly to the speaker.
void playSnare() {
  int initialMillis = TimingDelay;

  while (initialMillis - TimingDelay < 80) {

    // Xorshift is used as the pseudorandom number generator
    // as it has little detectable repetition, runs quickly, and is simple to implement.
    randomSeed ^= randomSeed << 13;
    randomSeed ^= randomSeed >> 17;
    randomSeed ^= randomSeed << 5;

    for (int j = 0; j < 32; ++j) {
      
      // "Unpack" each bit of the result in turn, as fast as possible
      if (randomSeed & (1 << j)) {
        GPIO_SetBits(GPIOB, GPIO_Pin_7);
      } else {
        GPIO_ResetBits(GPIOB, GPIO_Pin_7);
      }
    }
  }
}




// ===== INTERFACE RELATED CODE =====

// Enabling TEST_MODE stops the game from ending when a user misses a beat.
// Good for testing the music to make sure everything is playing correctly.
#define TEST_MODE 0

// Each character can have up to 3 indicators displayed.
// Indicators are first written here as the track is read,
// then the values in here are read and characters are written to the LCD.
// The intermediate step is required in order to avoid one indicator overwriting others.
uint8_t indicatorsByChar[] = {0b000, 0b000, 0b000, 0b000, 0b000, 0b000};

// Flag set if the user has pushed the button, and reset when user input is processed.
volatile int newButtonPress = 0;

// Flag set if the song is still playing, and reset if the user has lost.
volatile int isPlaying = 0;

// Show an indicator at the specified position
// (does not actually update LCD).
void setIndicator(int position, bool state) {
  position += 1;
  int character = position / 3;
  int column = position % 3;

  if (state) {
    indicatorsByChar[character] |= (1 << column);
  } else {
    indicatorsByChar[character] &= ~(1 << column);
  }
}

// Update the LCD based on the set indicators.
void updateIndicators() {
    // For the first char, draw the track position indicator
  char ch = '0' + indicatorsByChar[0];
  if (newButtonPress == 1) {
    LCD_GLASS_WriteChar(&ch, 1, 1, 1);
  } else {
    LCD_GLASS_WriteChar(&ch, 1, 0, 1);
  }

  // For subsequent characters, draw just the indicators
  for (int i = 1; i < 6; ++i) {
    ch = '0' + indicatorsByChar[i];
    LCD_GLASS_WriteChar(&ch, 0, 0, i+1);
  }
}

// Determine if the current beat has an indicator present
// (i.e., should the button be pressed for this beat?)
// Used to check end-game condition.
bool indicatorPresent(uint16_t track[], int index, int beatsSince) {
  return ((beatsSince == 0) && (track[index] & MASK_INDICATOR));
}


// Render a segment of a track at the given index.
// beatsSince is used as an "offset" as some messages on the track have a longer duration than 1 beat.
void renderTrack(uint16_t track[], int index, int beatsSince) {

  int beat = -beatsSince;

  // Peek ahead in the track as needed to determine upcoming indicators
  while (beat < 18) {
    if (track[index] == 0) {
      for (; beat < 18; ++beat) {
        setIndicator(beat, 0);
      }
      break;
    }

    if (beat >= 0) {
      if (track[index] & MASK_INDICATOR) {
        setIndicator(beat, 1);
      } else {
        setIndicator(beat, 0);
      }
    }

    int duration = (track[index] & MASK_DURATION) + 1;
    for (int i = beat + 1; i < beat + duration; ++i) {
      if (i >= 0) {
        setIndicator(i, 0);
      }
    }
    beat = beat + duration;

    ++index;
  }

  // Display upcoming indicators:
  updateIndicators();
}

// Check for end-game condition, reset keepPlaying flag as needed to end game
void checkEndGame(uint16_t track[], int index, int beatsSince) {
#if TEST_MODE
#else
  if (newButtonPress != indicatorPresent(track, index, beatsSince)) {
    isPlaying = 0;
  }
#endif
  newButtonPress = 0;
}

void displayPrompt(uint8_t* string) {
  LCD_GLASS_DisplayString(string);
  Delay(500);
  // Wait for a rising and falling edge on the button
  while (GPIO_ReadInputDataBit(USERBUTTON_GPIO_PORT, USERBUTTON_GPIO_PIN) == TRUE);
  while (GPIO_ReadInputDataBit(USERBUTTON_GPIO_PORT, USERBUTTON_GPIO_PIN) == FALSE);
  while (GPIO_ReadInputDataBit(USERBUTTON_GPIO_PORT, USERBUTTON_GPIO_PIN) == TRUE);
}

// ===== MAIN GAME LOGIC =====

// Render and play a packed message found in the track data.
void playPackedMessage(uint16_t track[], int index) {
  uint16_t message = track[index];
  int note = (message & MASK_NOTE) >> 8;
  int dutyCycle = (message & MASK_DUTY_CYCLE) >> 6 + 1;
  int beats = (message & MASK_DURATION) + 1;

  // Set Beat Time
  TimingDelay = millisPerBeat;
  renderTrack(track, index, 0);

  // Play percussion
  if (message & PERC_KICK) {
    playKick();
  } else if (message & PERC_SNARE) {
    playSnare();
  }

  // Check the end-game condition after playing the drum sound,
  // in case the user pressed the button slightly after the beat
  checkEndGame(track, index, 0);

  // Play note
  playNote(note, dutyCycle);
  
  // Keep playing the note if the duration of the message > 1
  for (int i = 1; i < beats; ++i) {

    // Stop playing if the "game over" flag is set
    if (!isPlaying) {
      return;
    }

    renderTrack(track, index, i);
    TimingDelay = millisPerBeat;
    checkEndGame(track, index, i);

    // Play note
    playNote(note, dutyCycle);
  }
}

// Play an entire track from start to finish.
void playTrack(uint16_t track[]) {
  setBPM(track[0]);
  isPlaying = 1;
  newButtonPress = 0;
  for (int i = 1;; ++i) {
    if (track[i] == 0) {
      isPlaying = 0;
      displayPrompt(" U WIN");
      return;
    }
    if (!isPlaying) {
      displayPrompt("U LOSE");
      return;
    }
    playPackedMessage(track, i);
  }
}

int main(void) {

  Init_Board();

  calibrateBusyWait();

  for(;;) {
    displayPrompt(" NOKIA");
    playTrack(nokiaTune);
    displayPrompt(" S G H");
    playTrack(suchGreatHeights);
  }
}


// ===== ISR's, etc. =====

void UserButtonDown(void)
{
  if (isPlaying) {
    newButtonPress = 1;
    char ch = '0'+indicatorsByChar[0];
    LCD_GLASS_WriteChar(&ch, 1, 1, 1);
  }
}

void UserButtonUp(void)
{

}

void Delay(unsigned int nTime)
{
  TimingDelay = nTime;
  while(TimingDelay != 0);
  
}

void Decrement_TimingDelay(void)
{
  if (TimingDelay != 0x00) { 
    TimingDelay--;
  }
}                                  

void Init_Board(void)
{ 
  /* Configure RTC Clocks */
  RTC_Configuration();

  /* Set internal voltage regulator to 1.8V */
  PWR_VoltageScalingConfig(PWR_VoltageScaling_Range1);

  /* Wait Until the Voltage Regulator is ready */
  while (PWR_GetFlagStatus(PWR_FLAG_VOS) != RESET) ;

  /* Enable debug features in low power modes (Sleep, STOP and STANDBY) */
#ifdef  DEBUG_SWD_PIN
  DBGMCU_Config(DBGMCU_SLEEP | DBGMCU_STOP | DBGMCU_STANDBY, ENABLE);
#endif
  
  /* Configure SysTick IRQ and SysTick Timer to generate interrupts */
  RCC_GetClocksFreq(&RCC_Clocks);
  SysTick_Config(RCC_Clocks.HCLK_Frequency / 1000);
  
  /* Initializes the LCD glass */
  LCD_GLASS_Configure_GPIO();
  LCD_GLASS_Init();

  /* Init I/O ports */
  Init_GPIOs();
}
		
//Configures the different system clocks.
void RCC_Configuration(void)
{  
  
  /* Enable HSI Clock */
  RCC_HSICmd(ENABLE);
  
  /*!< Wait till HSI is ready */
  while (RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET)
  {}

  RCC_SYSCLKConfig(RCC_SYSCLKSource_HSI);
  
  RCC_MSIRangeConfig(RCC_MSIRange_6);

  RCC_HSEConfig(RCC_HSE_OFF);  
  if(RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET )
  {
    while(1);
  }
 
  /* Enable  comparator clock LCD and PWR mngt */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_LCD | RCC_APB1Periph_PWR, ENABLE);
    
  /* Enable ADC clock & SYSCFG */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_SYSCFG, ENABLE);

}


void RTC_Configuration(void)
{
  
/* Allow access to the RTC */
  PWR_RTCAccessCmd(ENABLE);

  /* Reset Backup Domain */
  RCC_RTCResetCmd(ENABLE);
  RCC_RTCResetCmd(DISABLE);

  /* LSE Enable */
  RCC_LSEConfig(RCC_LSE_ON);

  /* Wait till LSE is ready */
  while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
  {}
  
  RCC_RTCCLKCmd(ENABLE);
   
  /* LCD Clock Source Selection */
  RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);

  /* Enable comparator clock LCD */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_LCD, ENABLE);

}

//To initialize the I/O ports
void conf_analog_all_GPIOS(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable GPIOs clock */ 	
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB | 
                        RCC_AHBPeriph_GPIOC | RCC_AHBPeriph_GPIOD | 
                        RCC_AHBPeriph_GPIOE | RCC_AHBPeriph_GPIOH, ENABLE);

  /* Configure all GPIO port pins in Analog Input mode (floating input trigger OFF) */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  GPIO_Init(GPIOB, &GPIO_InitStructure);
  GPIO_Init(GPIOC, &GPIO_InitStructure);
  GPIO_Init(GPIOD, &GPIO_InitStructure);
  GPIO_Init(GPIOE, &GPIO_InitStructure);
  GPIO_Init(GPIOH, &GPIO_InitStructure);
  
  /* Disable GPIOs clock */ 	
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB |
                        RCC_AHBPeriph_GPIOC | RCC_AHBPeriph_GPIOD | 
                        RCC_AHBPeriph_GPIOE | RCC_AHBPeriph_GPIOH, DISABLE);
}

void  Init_GPIOs (void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;
  
  /* Enable GPIOs clock */ 	
  RCC_AHBPeriphClockCmd(LD_GPIO_PORT_CLK | USERBUTTON_GPIO_CLK, ENABLE);
 
  /* Configure User Button pin as input */
  GPIO_InitStructure.GPIO_Pin = USERBUTTON_GPIO_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
  GPIO_Init(USERBUTTON_GPIO_PORT, &GPIO_InitStructure);

  /* Connect Button EXTI Line to Button GPIO Pin */
  SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);

  /* Configure User Button and IDD_WakeUP EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_Line0 ;  // PA0 for User button AND IDD_WakeUP
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);

  /* Enable and set User Button and IDD_WakeUP EXTI Interrupt to the lowest priority */
  NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn ;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

  NVIC_Init(&NVIC_InitStructure); 

/* Configure the GPIO_LED pins  LD3 & LD4*/
  GPIO_InitStructure.GPIO_Pin = LD_GREEN_GPIO_PIN | LD_BLUE_GPIO_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
  GPIO_Init(LD_GPIO_PORT, &GPIO_InitStructure);
  GPIO_LOW(LD_GPIO_PORT, LD_GREEN_GPIO_PIN);	
  GPIO_LOW(LD_GPIO_PORT, LD_BLUE_GPIO_PIN);

/* Disable all GPIOs clock */ 	
  RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOB | 
                        RCC_AHBPeriph_GPIOC | RCC_AHBPeriph_GPIOD | 
                        RCC_AHBPeriph_GPIOE | RCC_AHBPeriph_GPIOH, DISABLE);

  RCC_AHBPeriphClockCmd(LD_GPIO_PORT_CLK | USERBUTTON_GPIO_CLK, ENABLE);
}  

